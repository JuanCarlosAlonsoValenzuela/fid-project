```{r}
# install.packages("tidyverse")
library("tidyverse")
# install.packages("ggplot2")
library("ggplot2")
# install.packages("ggrepel")
library(ggrepel)
# install.packages("gridExtra")
library(gridExtra)
```

# Análisis del conjunto de datos
Comenzamos leyendo el conjunto de entrenamiento y el de pruebas, añadiendo también los nombres de los atributos
```{r}
headers <- c("age","workclass","fnlwgt","education","education_num","marital_status","occupation","relationship","race","sex","capital_gain","capital_loss","hours_per_week","native_country", "target")
# Read the training set:
train <- read.table("dataset/adult.data", sep=",", row.names=NULL)

# Add header names:
names(train) <- headers
dim(train)
head(train)
```

Cargamos el conjunto de pruebas.
```{r}
# Read the test set:
test <- read.table("dataset/adult.test", sep=",", row.names=NULL)
# Add header names:
names(test) <- headers
dim(test)
head(test)
```

TODO: Describir el número de atributos, número de instancias (training y test), origen del dataset, objetivo de la clasificación, etc.

Cargamos el  conjunto que contiene la combinación del conjunto de entrenamiento y pruebas, el archivo que contiene dicho conjunto ha sido creado ejecutando el script "join_training_and_test.R"
```{r}
# Read training and test set:
train_and_test <- read.table("dataset/train_and_test.data", sep=",", row.names=NULL, header=TRUE)
head(train_and_test)
dim(train_and_test)
```

Como puede verse, el número de instancias de este dataframe = train + test

# Analizar balance del dataset
Analizar en conjuntos separados y en el conjunto total
No hay missing values en el target (income)
Definimos una función que permite hacer pie chart...
Vemos que está desbalanceado, aplicaremos undersampling más adelante

```{r}
percentage_piechart <- function(dataframe, attribute_name, size_value) {
  count_target <- (dataframe %>% group_by(!!as.name(attribute_name)) %>% count())

  data <- data.frame(group=count_target[[attribute_name]], value=count_target$n)

  data <- data %>% 
    arrange(desc(group)) %>%
    mutate(prop = value / sum(data$value) *100) %>%
    mutate(ypos = cumsum(prop)- 0.5*prop )

  # Create a list of strings, each strings being the concatenation of an element of value and an element of prop
  labels <- paste(data$value, round(data$prop, 1), sep="(")

  ggplot(data, aes(x="", y=prop, fill=group)) +
    geom_bar(stat="identity", width=1, color="white") +
    coord_polar("y", start=0) +
    theme_void() + 
    geom_label_repel(aes(y = ypos, label = paste(labels, "%)")),
                    size = size_value, nudge_x = 1, show.legend = FALSE) +
    ggtitle(paste("Distribución de la variable ")) +
    theme(plot.title = element_text(hjust = 0.5, face="bold", size=20))
}
```

```{r}
percentage_piechart(train_and_test, "target", 6)
```

# Análisis de atributos categóricas
Analizaremos cada atributo categórico, tanto su distribución como el número/porcentaje de missing values
También analizaremos si hay alguna correlación entre cada atributo y el target
Detectaremos si hay valores no presentes en la especificación del dataset o typos
Eliminaremos y detectaremos outliers (atributos continuos)

## Análisis del atributo categórico  workclass

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "workclass", 4)
```

La clase mayoritaria (x.x%) es "Private" con una mayoría significativa
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x

## Análisis del atributo categórico education

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}	
percentage_piechart(train_and_test, "education", 3)
```

La clase mayoritaria (x.x%) es "XXX" con una mayoría significativa
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x


## Análisis del atributo categórico marital_status

### Distribución
Este atributo sirve para... puede tener los valores...

```{r}
percentage_piechart(train_and_test, "marital_status", 5)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x

## Análisis del atributo categórico occupation

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "occupation", 5)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x


## Análisis del atributo categórico relationship

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "relationship", 6)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x

## Análisis del atributo categórico race

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "race", 6)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x

## Análisis del atributo categórico sex

### Distribución
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "sex", 6)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x

## Análisis del atributo categórico native_country

### Distribución
TODO: IMPRIMIR CON UNA TABLA (VER PRÁCTICA TIDYVERSE) no cabe
Este atributo sirve para... puede tener los valores...
```{r}
percentage_piechart(train_and_test, "native_country", 4)
```

La clase mayoritaria (x.x%) es "XXX"
Hay x missing values (x%)
Valores no especificados en el dataset/typos: x


# Analizar missing values en todo el dataset


Analizar distribución de los valores (pie chart) de cada atributo
Los missing values se identifican mediante un signo de interrogación
Determinamos que lo mejor es omitirlos, ya que representan una minoría


# Análisis de atributos continuos
Analizaremos cada atributo continuo, tanto su distribución como el número/porcentaje de missing values
También analizaremos si hay alguna correlación entre cada atributo y el target
Eliminaremos y detectaremos outliers, como pueden ser los valores fuera de rango, este es el caso, por ejemplo, de edades negativas

## Análisis del atributo continuo  age
Contamos los valores de age inferiores a 16 (el mínimo de acuerdo a la descripción del dataset)
y superiores a 100.
```{r}
# Count the values of age that are below 0 or above 100
train_and_test %>% count(16 >= age | age >= 100)
```	

Imprimimos la distribución del atributo age, agrupado en intervalos de 10 años

Podemos comprobar que no existen valores nulos para el campo age
```{r}	
# Print all the values of age that are not numbers
train_and_test %>% filter(age %in% c("", "NA", "?")) %>% count()
```

```{r}
colnames(train_and_test)	
```
```{r}
# Split the age column in intervals of 10 years
train_and_test$age <- as.numeric(train_and_test$age)
age_intervals <- train_and_test %>%
  mutate(decade = floor(age/10)*10) %>%
  group_by(decade) %>%
  count(decade) 

age_intervals
```

```{r}
percentage_piechart_continuous_attribute <- function(dataframe, attribute_name, size_value, interval_size, normalization_value) {
  count_target <- dataframe %>% mutate(chunks = floor(dataframe[[attribute_name]]/interval_size)*normalization_value) %>%
    group_by(chunks) %>%
    count(chunks)

print(count_target)
}
```	

```{r}

```

# Analizar outliers
Edades negativas o superiores a 100, variables categóricas no especificadas en la descripción del dataset, etc.

# Analizar relaciones entre variables (Correlación)

# Aplicar undersampling (Quitando missing values)
Explicar que aplicaremos los algoritmos con y sin undersampling